# Сервис баннеров
## Описание

Сервис баннеров - сервис, который позволяет показывать пользователям баннеры, в зависимости от требуемой фичи и тега пользователя, а также управлять баннерами и связанными с ними тегами и фичами.

Баннер — это документ, описывающий какой-либо элемент пользовательского интерфейса. Технически баннер представляет собой JSON-документ неопределенной структуры.  

Тег — это сущность для обозначения группы пользователей; представляет собой число (ID тега).  

Фича — это домен или функциональность; представляет собой число (ID фичи).

1. Один баннер может быть связан только с одной фичей и несколькими тегами
2. При этом один тег, как и одна фича, могут принадлежать разным баннерам одновременно
3. Фича и тег однозначно определяют баннер

## API 

Описание ручек и примеры запросов можно посмотреть [тут](docs/api)

Спецификация [OpenAPI](api/openapi.yaml)

------------------------------------------------------------------------------------------------------------------------

## Сборка проекта
### Продовое окружение

Чтобы собрать продовое окружение, для начала нужно создать `.env` файл - это можно сделать с помощью команды `make env`, которая создает абсолютную копию файла `.env.example`.
В файле `.env` задаются следующие переменные, которые можно изменить при необходимости: 

| Переменная                                        | Описание                              |
|---------------------------------------------------|---------------------------------------|
| POSTGRES_PORT=5432                                | Порт СУБД                             |
| POSTGRES_USER=user                                | Пользователь БД                       |
| POSTGRES_PASSWORD=1234                            | Пароль для пользователя POSTGRES_USER |
| POSTGRES_DB=banner                                | Название БД                           |
| APP_PORT=8080                                     | Порт приложения                       |
| APP_HOST=0.0.0.0                                  | Хост                                  |
| ADMIN_TOKEN=admin                                 | Токен админа                          |
| USER_TOKEN=user                                   | Токен пользователя                    |
| GIN_MODE=release                                  | Режим (release) gin в сервисе         |
| PG_URL=postgres://user:1234@postgres:5432/banner  | Ссылка на БД в Postgres для сервиса   |


Далее достаточно выполнить команду:

```shell
make
```

После выполнения команды запустятся сервис и СУБД в Docker контейнерах с заданными параметрами.

По окончании работы рекомендуется выполнить команду:
```shell
make clean
```

### Тестовое окружение

Чтобы поднять тестовое окружение, достаточно выполнить команду:

```shell
make test-env
```

После выполнения команды запустится сервис на **8888** и СУБД Postgresql на **4444** в Docker контейнерах

По окончании работы рекомендуется выполнить команду:
```shell
make clean-test-env
```

------------------------------------------------------------------------------------------------------------------------

## Тестирование

Проект содержит юнит тесты, которые лежат вместе с тестируемыми компонентами, интеграционные и e2e тесты в директории [tests](tests).

Чтобы запустить все тесты, достаточно выполнить команду:

```shell
make test
```

Для тестирования поднимается тестовое окружение и локально запускаются все тесты.
![](docs/test/test.png)


------------------------------------------------------------------------------------------------------------------------
## Нагрузочное тестирование
### Конфигурация 

1) В качестве инструмента нагрузочного тестирования использовался _jmeter_. Нагрузка на сервис 1000 RPS. Результаты тестирования и данные запросов лежат в файле [Thread Group.jmx](docs/load_testing/Thread Group.jmx).
![thread_group.png](docs%2Fload_testing%2Fthread_group.png)
2) Для заполнения базы данных бы написан простой [скрипт на python](tests/data/dbfill.py), который создает 1000 записей с баннерами минимум по 3 тега и 1 фичей у каждого. Контент генерировался случайно по _json_ схеме в скрипте.
3) Чтобы имитировать поведение пользователей на получение записей, было создано 10 запросов с получением записи по тегу и фиче. У каждого запроса тег и фича были равны и принимали значения от 1 до 9.
Один запрос имел флаг `use_last_revision=true`, чтобы имитировать 10% получение баннеров с актуальной информацией.
![user_example.png](docs%2Fload_testing%2Fuser_example.png)

### Результаты:

1) Средние показатели

![aggregate_report.png](docs%2Fload_testing%2Faggregate_report.png)

2) Ответы сервиса

![result_tree.png](docs%2Fload_testing%2Fresult_tree.png)

------------------------------------------------------------------------------------------------------------------------

## Проблемы и ответы на вопросы

### Проблема с логированием запросов БД

В начале разработки был выбран zap логгер в качестве основы проекта, однако в pgx/v5 был изменен интерфейс логгера, 
но адаптер для zap остался старый, из-за чего пришлось писать своими руками.

### Почему tag_id и feature_id обязательные параметры баннера? 

Конкретного ограничения на обязательность полей нет, однако если у баннера нет тега и фичи, то это значит, что баннер 
в системе не определен, что является бессмысленным. Если есть цель не показывать баннер, то достаточно баннер отключить.

### Проблемы со структурой БД

Чтобы не дублировать записи контента в одном отношении БД, записи с баннерами вынесены в отдельную таблицу для нормализации. 
Однако это сильно усложнило запросы, в частности запросы на обновление баннера через `PATCH`. Для обновления записи было принято решение
обновление отдельных атрибутов отдельными запросами в одной транзакции, что гарантировало полное обновление запроса или полное не обновление.

### Проблемы с типами данных pgx

В pgx нет поддержки конвертации массивов Postgres в стандартные примитивы языка Go, поэтому для работы с массивами внутри реализации `PostresRepo`
Была создана структура для работы с типами из Postgres и последующей конвертацией их в стандартные типы, чтобы все приложение могло работать с этими данными.
